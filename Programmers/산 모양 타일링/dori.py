"""
https://school.programmers.co.kr/learn/courses/30/lessons/258705
"""


def solution(n, tops):
    """
    - 약 2시간 풀이 후 실패로 힌트 참조 + 30분 추가 풀이
    - Tops 각각을 고려한 DP테이블을 어떻게 설계할 것인가?
        - Tops 의 길이가 최대 10만 -> O(N^2) 로는 불가능
        - O(N)으로 Tops 각각을 고려하는 점화식 vs 한 번 DP테이블 계산 이후 Tops 를 계산하는 방식(O(2N))이 있을 듯함
    - 우선 Tops 가 모두 0인 경우를 고려하는 것이 규칙을 찾아내기 더 수월할 듯함
        - n 이 추가됐을 때 맨 오른쪽이 아무것도 없는 경우
            - dp[n-1]
        - n 이 추가됐을 때 맨 오른쪽이 사다리꼴로 꽉차있는 경우
            - dp[n-1]
        - n 이 추가됐을 때 맨 오른쪽의 일부(왼쪽)만 차있는 경우
            - dp[n-1] - dp[n-2]
    - 정리해보자면, Tops 가 모두 0일 때 점화식 -> 2 * dp[n-1] + (dp[n-1] - dp[n-2])
    - 그럼 위에 탑이 하나 쌓였을 때를 살펴보자
        - 쌓인 탑을 활용 X
            - dp[n]
        - 쌓인 탑을 활용 (그러기 위해서 다이아 모양 사다리꼴 하나 놓음)
            - dp[n-1]
        - 라고 생각했지만 쌓인 탑을 연속으로 사용할 경우 분할 실패 ...

    - 힌트 참조
        - 카카오 공식 해설(https://tech.kakao.com/2023/12/27/2024-coding-test-winter-internship/)
        - 가능한 경우의 수를 분할하여 DP 테이블을 두 개로 설계
        - n 이 추가될 때 \ 모양의 사다리꼴을 사용하는지, 안하는지로 분할
            - 해당 모양의 사다리꼴을 사용한다면 Tops 를 사용하지 못하므로 복잡한 경우를 고려한 분할이 수월해짐
        - a[i] = a[i-1] + b[i-1]
            - 현재 주어진 i번째 타일에 \ 모양을 사용하면 탑이 있던 없던 사용 불가능
            - 따라서 이전 i-1번째 타일까지의 경우의 수와 동일
        - b[i] = (1 + tops[i-1]) * a[i-1] + (2 + tops[i-1]) * b[i-1]
            - (1 + tops[i-1]) * a[i-1]
                - \ 모양을 사용하지않으므로, 탑이 없다면 정삼각형만 사용하므로 경우의 수 1
                - 탑이 있다면 마름모 하나 추가로 가능 -> 경우의 수 2
            - (2 + tops[i-1]) * b[i-1]
                - 이전 타일에서 \ 를 사용하지 않으면 현재 타일에 / 모양 사다리꼴 사용 가능 -> 1
                - 또한 정삼각형으로 다 채우는 경우의 수 -> 1
                - 여기까지 2인데 탑이 있다면 마름모 하나 추가로 가능 -> 경우의 수3

    """
    a = [0] * (n + 1)  # 현재 주어진 i번째 타일에 \ 모양을 사용했을 경우
    b = [0] * (n + 1)
    a[1] = 1  # 타일이 하나만 있다면 \ 를 놓으면 나머지는 전부 정삼각형
    b[1] = 3 if tops[0] == 1 else 2  # 쌓인 탑이 있다면 마름모 하나 두는 경우 추가

    for i in range(2, n + 1):
        a[i] = (a[i - 1] + b[i - 1]) % 10007
        b[i] = ((1 + tops[i - 1]) * a[i - 1] + (2 + tops[i - 1]) * b[i - 1]) % 10007

    return (a[n] + b[n]) % 10007
