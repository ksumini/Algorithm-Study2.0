"""
<문제>
-1, +1, -10, +10, -100, +100 과 같이 절댓값이 10^c(c>=0인 정수) 형태인 정수들이 적힌 버튼
버튼을 누르면 현재 층 수에 버튼에 적혀 있는 값을 더한 층으로 이동하게 된다.
단, 엘리베이터가 위치해 있는 층과 버튼의 값을 더한 결과가 0보다 작으면(=음수면) 엘리베이터는 움직이지 않는다.
0층이 가장 아래층이며, 엘리베이터는 현재 민수가 있는 층에 있다.

최소한의 버튼을 눌러서 이동하려고 한다.
어떤 층에서 0층으로 내려가는데 필요한 마법의 돌의 최소 개수

<제한 사항>
1 ≤ storey ≤ 100,000,000

<풀이 시간>
40분

<풀이>
수 제한이 매우 크기 때문에 그리디로 접근했다.
버튼이 모두 10의 배수이기 때문에 10으로 나누어 몫과 나머지를 사용하면 수를 빠르게 줄일 수 있을 거라고 생각하고 풀이
현재 층에서 위로 올라가는 것이 이득인지, 아래로 내려가는 것인지 이득인지를 나머지로 판단한다.

예를 들어, 마지막 자리 수가 5보다 크다면 위로 위로 올라가는 것이 더 이득이다.
반대로, 5보다 작다면 내려가는 것이 더 이득인 경우
가장 마지막으로, 만약 10으로 나눈 나머지(즉, 일의 자리 수가 5와 같다면 10의 자리수가 5 이상인 경우 역시 위로 올라가는 것이 더 이득이다)

ex) storey가 565785라면..

565785에서 565780으로 이동하는 것보다 565790으로 이동하는 것이 더 이득이다.
왜냐면 다음에 10으로 또 나누었을 때 일의 자리 수가 각각 8과 9가 되는데, 이 때 10으로 올려주려면
이동해야 하는 숫자가 각각 2, 1이 되기 때문에 십의 자리수가 5보다 크다면 위로 올리는 것이 더 이득이다.

<시간 복잡도>
storey가 0이 될 때까지 반복 -> 즉, storey의 자리수가 하니씩 줄어듬 -> O(len(storey))
"""


def solution(storey: int) -> int:
    """
    :param storey: 시작 층(민수가 있는 위치)
    :return: 0층으로 가기 위해 필요한 마법의 돌의 최솟값
    """
    answer = 0
    while storey:
        remainder = storey % 10
        if remainder > 5 or (remainder == 5 and (storey // 10) % 10 >= 5):
            storey += (10-remainder)
            answer += (10-remainder)
        else:
            answer += remainder
        storey //= 10

    return answer